
"""
Database management for SmartLarva Edge.

This module wraps SQLite operations in a ``Database`` class to handle
creation of tables, insertion of records, updates, and queries. It also
defines dataclasses representing core entities: crates, events, images and
sensor readings.

All database operations are executed in a thread-safe manner by serializing
through a single connection with ``check_same_thread=False`` and using
``threading.Lock`` if accessed from multiple threads.

The schema corresponds to the "SmartLarva Edgeâ€“Cloud Sync Protocol", using
local identifiers on the edge device. The tables and columns are defined
according to the design document.

The ``Database`` class ensures that tables are created on initialization.
"""

from __future__ import annotations

import sqlite3
import threading
from dataclasses import dataclass
from typing import Optional, List
import os

@dataclass
class CapturedImageRecord:
    id: Optional[int]
    event_local_id: int
    image_index: int
    local_path: str
    captured_at: str
    size_bytes: int
    sha256_hex: str
    width_px: Optional[int]
    height_px: Optional[int]
    format: Optional[str]
    metadata_uploaded: int = 0
    uploaded: int = 0
    local_exists: int = 1
    corrupted: int = 0

@dataclass
class CaptureEventRecord:
    event_id: int  # event_local_id
    crate_id: int
    camera_name: str
    captured_at: str
    burst_size: int
    uploaded: int = 0  # metadata uploaded flag

@dataclass
class SensorReadingRecord:
    reading_id: int  # reading_local_id
    crate_id: int
    recorded_at: str
    temperature_c: Optional[float]
    humidity_pct: Optional[float]
    uploaded: int = 0

@dataclass
class CrateRecord:
    """Represents a crate (experiment) metadata record.

    ``id`` is user-defined and must be provided via YAML configuration. It is
    treated as a primary key and will not be auto-generated by SQLite. The
    ``created_at`` field stores the start date of the crate (ISO-8601 string).
    ``ended_at`` may be ``None`` if the crate is still active.
    """
    id: int
    crate_label: str
    location: Optional[str]
    notes: Optional[str]
    created_at: str
    ended_at: Optional[str]


class Database:
    """Encapsulates SQLite database operations for SmartLarva Edge."""

    def __init__(self, db_path: str) -> None:
        self.db_path = db_path
        # Ensure directory exists
        db_dir = os.path.dirname(db_path)
        if db_dir and not os.path.exists(db_dir):
            os.makedirs(db_dir, exist_ok=True)

        self.conn = sqlite3.connect(self.db_path, check_same_thread=False)
        # Row factory returns dict-like row objects
        self.conn.row_factory = sqlite3.Row
        self.lock = threading.Lock()
        self._create_tables()

    def _create_tables(self) -> None:
        """Create tables if they do not already exist."""
        with self.conn:
            self.conn.executescript("""
            CREATE TABLE IF NOT EXISTS crates_local (
                id INTEGER PRIMARY KEY NOT NULL,
                crate_label TEXT NOT NULL UNIQUE,
                location TEXT NULL,
                notes TEXT NULL,
                created_at TEXT NOT NULL,
                ended_at TEXT NULL
            );

            CREATE TABLE IF NOT EXISTS capture_events_local (
                event_id INTEGER PRIMARY KEY,
                crate_id INTEGER NOT NULL,
                camera_name TEXT NOT NULL,
                captured_at DATETIME NOT NULL,
                burst_size INTEGER NOT NULL,
                uploaded INTEGER NOT NULL DEFAULT 0,
                FOREIGN KEY(crate_id) REFERENCES crates_local(id)
            );

            CREATE TABLE IF NOT EXISTS images_local (
                id INTEGER PRIMARY KEY,
                event_local_id INTEGER NOT NULL,
                image_index INTEGER NOT NULL,
                local_path TEXT NOT NULL,
                captured_at DATETIME NOT NULL,
                size_bytes INTEGER NOT NULL,
                sha256_hex TEXT NOT NULL,
                width_px INTEGER NULL,
                height_px INTEGER NULL,
                format TEXT NULL,
                metadata_uploaded INTEGER NOT NULL DEFAULT 0,
                uploaded INTEGER NOT NULL DEFAULT 0,
                local_exists INTEGER NOT NULL DEFAULT 1,
                corrupted INTEGER NOT NULL DEFAULT 0,
                UNIQUE(event_local_id, image_index),
                FOREIGN KEY(event_local_id) REFERENCES capture_events_local(event_id)
            );

            CREATE TABLE IF NOT EXISTS sensor_readings_local (
                reading_id INTEGER PRIMARY KEY,
                crate_id INTEGER NOT NULL,
                recorded_at DATETIME NOT NULL,
                temperature_c REAL NULL,
                humidity_pct REAL NULL,
                uploaded INTEGER NOT NULL DEFAULT 0,
                FOREIGN KEY(crate_id) REFERENCES crates_local(id)
            );

            CREATE TABLE IF NOT EXISTS state (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL
            );
            """)

    def insert_crate(self, record: CrateRecord) -> int:
        """Insert a crate record (with user-defined ID) and return its ID.

        Crates are uniquely identified by their ``id``. The ``crate_label``
        must also be unique, so both the ID and label act as constraints. If
        a row with the same ID or label already exists, the insert is
        ignored. This method always returns the resolved ID (existing or
        newly inserted).

        Args:
            record: The crate metadata to insert. ``record.id`` must be
                provided from YAML. ``record.created_at`` should be an ISO
                date string. ``record.ended_at`` may be None.

        Returns:
            The integer primary key ID of the crate row.
        """
        with self.conn:
            # Always attempt to insert the crate using the provided ID.
            self.conn.execute(
                """
                INSERT OR IGNORE INTO crates_local
                    (id, crate_label, location, notes, created_at, ended_at)
                VALUES (?, ?, ?, ?, ?, ?)
                """,
                (
                    record.id,
                    record.crate_label,
                    record.location,
                    record.notes,
                    record.created_at,
                    record.ended_at,
                ),
            )
            # Verify that the crate exists and matches the provided ID and label
            row = self.conn.execute(
                "SELECT id, crate_label FROM crates_local WHERE id = ?",
                (record.id,),
            ).fetchone()
            if row is None:
                # If the ID isn't found, something went wrong (e.g., conflicting label)
                # Try lookup by label to detect mismatch
                row_label = self.conn.execute(
                    "SELECT id FROM crates_local WHERE crate_label = ?",
                    (record.crate_label,),
                ).fetchone()
                if row_label is None:
                    raise RuntimeError(
                        f"Failed to insert or find crate with id={record.id} label={record.crate_label}"
                    )
                # If the label exists but with a different ID, this is a config error
                raise sqlite3.IntegrityError(
                    f"crate_label '{record.crate_label}' exists with id={row_label['id']}, but YAML specifies id={record.id}. "
                    f"Resolve the ID conflict (clear DB or adjust YAML)."
                )

            if row["crate_label"] != record.crate_label:
                raise sqlite3.IntegrityError(
                    f"Crate ID {record.id} already used by label '{row['crate_label']}', but YAML specified label '{record.crate_label}'."
                )

            return row["id"]

    def insert_event(self, record: CaptureEventRecord) -> None:
        """Insert a capture event record."""
        with self.conn:
            self.conn.execute(
                """INSERT INTO capture_events_local
                       (event_id, crate_id, camera_name, captured_at, burst_size, uploaded)
                       VALUES (?, ?, ?, ?, ?, ?)""",
                (
                    record.event_id,
                    record.crate_id,
                    record.camera_name,
                    record.captured_at,
                    record.burst_size,
                    record.uploaded,
                ),
            )

    def insert_image(self, record: CapturedImageRecord) -> None:
        """Insert an image record."""
        with self.conn:
            self.conn.execute(
                """INSERT INTO images_local
                       (event_local_id, image_index, local_path, captured_at,
                        size_bytes, sha256_hex, width_px, height_px, format,
                        metadata_uploaded, uploaded, local_exists, corrupted)
                       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    record.event_local_id,
                    record.image_index,
                    record.local_path,
                    record.captured_at,
                    record.size_bytes,
                    record.sha256_hex,
                    record.width_px,
                    record.height_px,
                    record.format,
                    record.metadata_uploaded,
                    record.uploaded,
                    record.local_exists,
                    record.corrupted,
                ),
            )

    def insert_sensor_reading(self, record: SensorReadingRecord) -> None:
        """Insert a sensor reading record."""
        with self.conn:
            self.conn.execute(
                """INSERT INTO sensor_readings_local
                       (reading_id, crate_id, recorded_at, temperature_c, humidity_pct, uploaded)
                       VALUES (?, ?, ?, ?, ?, ?)""",
                (
                    record.reading_id,
                    record.crate_id,
                    record.recorded_at,
                    record.temperature_c,
                    record.humidity_pct,
                    record.uploaded,
                ),
            )

    def mark_event_uploaded(self, event_id: int) -> None:
        """Mark a capture event metadata as uploaded."""
        with self.conn:
            self.conn.execute(
                "UPDATE capture_events_local SET uploaded = 1 WHERE event_id = ?",
                (event_id,),
            )

    def mark_image_metadata_uploaded(self, event_local_id: int) -> None:
        """Mark all images for an event as having metadata uploaded."""
        with self.conn:
            self.conn.execute(
                "UPDATE images_local SET metadata_uploaded = 1 WHERE event_local_id = ?",
                (event_local_id,),
            )

    def mark_image_uploaded(self, event_local_id: int, image_index: int) -> None:
        """Mark a specific image binary as uploaded."""
        with self.conn:
            self.conn.execute(
                """UPDATE images_local
                       SET uploaded = 1
                       WHERE event_local_id = ? AND image_index = ?""",
                (event_local_id, image_index),
            )

    def mark_reading_uploaded(self, reading_id: int) -> None:
        """Mark a sensor reading as uploaded."""
        with self.conn:
            self.conn.execute(
                "UPDATE sensor_readings_local SET uploaded = 1 WHERE reading_id = ?",
                (reading_id,),
            )

    def mark_image_corrupted(self, image_id: int) -> None:
        """Mark an image as corrupted (upload failed)."""
        with self.conn:
            self.conn.execute(
                "UPDATE images_local SET corrupted = 1 WHERE id = ?",
                (image_id,),
            )

    def get_unsynced_events(self, limit: int = 10):
        """Return unsynced events with metadata not uploaded."""
        cursor = self.conn.execute(
            "SELECT * FROM capture_events_local WHERE uploaded = 0 ORDER BY event_id LIMIT ?",
            (limit,),
        )
        return cursor.fetchall()

    def get_unsynced_images(self, limit: int = 10):
        """Return images whose metadata has been uploaded but binary not uploaded."""
        cursor = self.conn.execute(
            """SELECT * FROM images_local
                   WHERE metadata_uploaded = 1 AND uploaded = 0 AND corrupted = 0
                   ORDER BY event_local_id, image_index
                   LIMIT ?""",
            (limit,),
        )
        return cursor.fetchall()

    def get_images_for_event(self, event_local_id: int):
        """Return all image records for a given event."""
        cursor = self.conn.execute(
            "SELECT * FROM images_local WHERE event_local_id = ? ORDER BY image_index", (event_local_id,)
        )
        return cursor.fetchall()

    def get_sensor_readings(self, uploaded: int = 0, limit: int = 10):
        """Return sensor readings filtered by upload status."""
        cursor = self.conn.execute(
            "SELECT * FROM sensor_readings_local WHERE uploaded = ? ORDER BY reading_id LIMIT ?",
            (uploaded, limit),
        )
        return cursor.fetchall()

    def set_state_value(self, key: str, value: str) -> None:
        """Store or update a state value (e.g., safe delete watermark)."""
        with self.conn:
            self.conn.execute(
                "INSERT OR REPLACE INTO state (key, value) VALUES (?, ?)",
                (key, value),
            )

    def get_state_value(self, key: str):
        """Retrieve a state value by key."""
        cursor = self.conn.execute(
            "SELECT value FROM state WHERE key = ?",
            (key,),
        )
        row = cursor.fetchone()
        return row['value'] if row else None

    def get_cleanup_candidates(self, safe_delete_event_id: int, retention_days: int, limit: int = 100):
        """Return images eligible for cleanup.

        An image is eligible if:
         - its binary has been uploaded (uploaded=1),
         - the event_local_id is <= safe_delete_event_id,
         - local_exists=1,
         - its captured_at is older than retention_days.
        """
        cursor = self.conn.execute(
            """SELECT * FROM images_local
                   WHERE uploaded = 1 AND local_exists = 1
                     AND event_local_id <= ?
                     AND DATE(captured_at) <= DATE('now', ? || ' days')
                   LIMIT ?""",
            (safe_delete_event_id, f'-{retention_days}', limit),
        )
        return cursor.fetchall()

    def mark_image_deleted(self, image_id: int) -> None:
        """Mark an image as deleted locally."""
        with self.conn:
            self.conn.execute(
                "UPDATE images_local SET local_exists = 0 WHERE id = ?",
                (image_id,),
            )

    def close(self) -> None:
        """Close the database connection."""
        self.conn.close()
